\chapter{Detección óptica de caracteres (OCR)}
En este capitulo se pretende explicar que es el OCR, obtener una idea basica 
de los distintos algorimos que se pueden implementar para 
utilizar esta tecnica, para luego centrarnos en la red convolucional entrenada por 
Ankandrew [referencia al git], con la idea de finalizar en un algoritmo en Python 3 
que permita obtener los caracteres de una patente mediante una imagen.

\section{Algoritmos de OCR}
Como primera instancia vamos a definir que es OCR, por sus siglas en ingles Optical character
Recognition o en español Reconocimiento Optico de caracteres, es una tecnica que permite 
obtener texto en un formato editable para una maquina(ASCII o Unicode)a partir de una imagen 
de texto.
Para logarlo el software inspecciona la imagen buscando formas que coincidan con la forma 
de los caracteres, y dependiendo del tipo de software las compara con una base disponible
para el programa o trata de identificarlos mediante el analisis de sus caracteristicas.
La tecnologia más utiliza para realizar el OCR es la de Redes Neuronales, ya sea 
mediante redes LSTM por sus siglas en ingles Long-Short Term Memory, que son una variedad de Redes
neuronales recurrentes o bien CNN por sus siglas en ingles Convolutional Neural Network, o en español Red
Neuronal Convolucional.

Si bien el fin ultimo de ambos tipos de red es obtener los caracteres a partir de la imagen,la forma en 
trabajan difiere significamente, las redes LSTM almacenan informacion de estados anteriores mediante bucles,
lo que les permite realizar predicciones de estados futuros usando informacion pasada almacenada y la informacion
del estado actual.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.25\textwidth]{imgs/LSTM-diagrama.jpg}
    \label{fig:diagrama-LSTM}
    \caption{Diagrama basico red LSTM.}
    \end{figure}
Este tipo de redes son las mas utilizadas actualmente para realizar reconocimiento de 
caracteres, pero cuentan con la desventaja de requerir mayor poder de computo, por la necesidad
almacenar y anidar datos anteriores.

La otra alternativa que se utiliza es la de Redes Neuronales del tipo convulucional, que mediante 
el uso de convoluciones entre los pixeles de la imagen y una serie de matrices establecidas
extrae caracteristicas utilizadas para comparar la imagen con una lista de valores posibles,
dando por resultado el caracter que mas similitud tenga con el set de comparacion.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.25\textwidth]{imgs/CNN-diagrama.jpg}
    \label{fig:diagrama-CNN}
    \caption{Diagrama basico red CNN.}
    \end{figure}

Al no requerir almacenar informacion ni trabajar de forma recursiva, la implementacion
de este tipo de redes pueden ser implementadas en equipos con un hardware de menor potencia,menor tamaño y 
por consiguiente menor costo.

Por lo que esta ultima opcion es de las mas utilizadas a la hora de colocar en sistemas embedidos de baja 
potencia, o que por cuestiones de energia tengan un consumo menos reducido. Como el objetivo de nuestro PIP el diseño
de un sistema que pueda ser utilizado en diferentes entornos, se considero que esta era la mejor opcion para 
el desarrollo.

De varios algoritmos encontrados que realizan OCR mediante redes neuronales convolucionales, se encontro uno
preentrenado para la deteccion de patentes argentinas, tanto para la versiones antiguas del año 1994 como para la version moderna del 
mercosur del año 2015, las cuales se pueden ver en la Fig.\ref{fig:patentes-arg}. [https://www.iprofesional.com/autos/376250-como-saber-el-ano-de-un-auto-por-la-patente-en-argentina]
\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{imgs/patentes-arg.png}
    \label{fig:patentes-arg}
    \caption{evolucion Patentes Argentinas.}
\end{figure}
Este algoritmo como se menciono al inicio del capitulo fue entrenado por Ankandrew, el cual es un modelo convencional de red convolucional 
formada por un bloque convolucional, luego un bloque Batch-Normalization, una funcion de activacion, seguida por un bloque de MaxPooling 
continuada por un bloque GlobalAvgPooling para finalizar en una fully Conected Layer de 37x7, esto surge de que maximo se poseen 7 caracteres
de salida y el 37 de la suma de las 26 letras del abcedario, los 10 numeros del 0 al 9 y el simbolo $\_$ utilizado para el caso de las patentes antiguas 
que solo poseen 6 caracteres, todos los terminos descriptos anteriormente seran explicados en la siguiente seccíon.

\section{Marco teórico}
Como se viene mencionando durante las secciones anteriores se usara una red neuronal del tipo convolucional para realizar el algoritmo de OCR,
pero bien para comprender como trabaja un red convolucional es necesario saber primero que es una red neuronal y como esta se constituye.

Entonces ¿qué es una red nueronal?, se define entonces como red neuronal a un algoritmo computacional que intenta imitar el cerebro 
humano, en otras palabras es un algoritmo de computación compuesto por un gran numero de elementos simples que se 
encuentran interconectados, los cuales procesan la información por medio de estados dinámicos, respondiendo a entradas externas,esquematizado en 
 la Fig. \ref*{fig:esquema-redes}.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{imgs/Redes-esquema.jpg}
    \label{fig:esquema-redes}
    \caption{Esquema simplificado de una red neuronal.}
\end{figure}
Debido a la semenjanza que existe entre los algoritmos de Deep Learning (algoritmos de aprendizaje computacional o 
Machine learning [Referencia https://www.ibm.com/topics/machine-learning] compuesto por redes neuronales 
de 3 o mas capas)[Referencia https://www.ibm.com/es-es/topics/deep-learning] y el cerebro humano , a la 
unidad fundamental de estos sistemas se la denomina neurona, apreciado en la Fig. \ref*{fig:comparativa-neuronas}
\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{imgs/comparacion-neurona-red.png}
    \label{fig:comparativa-neuronas}
    \caption{Comparacion neurona biologica con nuerona artificial.}
    %https://futurelab.mx/redes%20neuronales/inteligencia%20artificial/2019/06/25/intro-a-redes-neuronales-pt-1/
\end{figure}
Cada neurona o unidad fundamental de la red procesa la información de un grupo de neuronas previas y la entrega al siguiente grupo,este proceso 
se puede entender como la sinapsis neuronal de los seres vivos.

La sinapsis entre nueronas es una suma poderada que puede ser expresada como $Y =W^T\dot X + b$ donde $Y$ es el vector de salida de la nuerona,
 $W$ representa los pesos de la neurona, $b$ es un bias y $X$ es el vector de entrada.
Es posible realizar un arreglo en paralelo de neuronas, lo cual recibe el nombre de capa,las capas se interconectan para crear redes 
más complejas capaces de realizar tareas más especificas Fig.\ref*{fig:esquema-redes}.

Debido a que en esencia el proceso que realiza la neurona es una transformación lineal, al interconectar capas la resultante sigue siendo 
una transformación lineal. Este problema de linealidad se soluciona aplicando una función de activación o transformacion no lineal,
luego de la transformación lineal, obteniendo $Y= f(W^T \dot X + b)$, algunas de estas funciones las podemos ver en la 
Fig. \ref*{fig:funciones-activacion}.
\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{imgs/Funciones-de-activacion.jpg}
    \label{fig:funciones-activacion}
    \caption{Funciones de activacion más comunes.}
\end{figure}
Como este trabajo esta centrando en el trabajo con imagenes las redes mas utilizadas son las redes neuronales de convolución o 
CNN Convolutional Neuronal Network por sus siglas en inglés, ya que su diseño se basa en la estructura de la corteza visual animal, esta 
imitación se consigue utilizando convoluciones bidimensionales. Este tipo de redes poseen caracteristicas que las hacen unicas, por lo que 
se prodece a continuacion a enumerar las partes que la componen y se muestra un esquema de la misma en la Fig. \ref*{fig:esquema-CNN}
\begin{itemize}
    \item Capa convolucional: capa principal de de las CNN, sus parametros son basicamente filtros entrenables de tamaño reducido, cada una 
    de ellas produce un mapa de activacion bidimensional. Cada uno de estos filtros se activara segun la caracteristica que se busque.
    \item Capa de agrupacion: se coloca entre las capas de convolucion, toma los mapas de caracteristicas producidos por la capa de 
    convolucion y los agrupa en una imagen. En esta capa se produce una reduccion de la dimesion, lo que reduce la complejidad para evitar el sobreajuste de los parametros.
    \item Capa de activacion: la unica funcion de esta capa es la de aumentar la no linealidad sin modificar los parametros, no son entrenables 
    por lo que por ella solo se propagan los errores calculados.
    \item capa completamente conectada: tiene la estructura comun de una capa de nueronas pero con las particularidad que todas las neuronas 
    de esta capa estan conectadas a todas las neuronas de la capa anterior.
    \item capa de perdida
\end{itemize}
\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{imgs/CNN-completa.jpg}
    \label{fig:esquema-CNN}
    \caption{Esquema de un red del tipo CNN.}
\end{figure}
Antes de continuar haremos una pausa para explicar el comportamiento de la convolución bidimensional, es similar al caso conocido en 1D con 
algunas modificaciones, por ejemplo se habla de sistemas LSI (lineales de espacio invariante) en vez de sistemas Lineales invariantes 
en el tiempo, para tenerla presente se procede a explicar la definición de convolución discreta en 2  dimensiones.

Se define filtro, núcleo ó matriz de convolución a la respuesta de un sistema LSI discreto, el filtro es dimensión $2k x 2k$ donde $k$ es un 
valor establecido arbitrario (usualmente son matrices cuadradas de $3x3$ o $5x5$) que define cuantos valores habra de la muestra.

Se define a $h[n]$ como un filtro de dimension $2k x 2k$ e $I$ una imagen a escala de grises, donde cada punto de coordenadas $(i,j)$ es el 
resultado de la convolucion entre $h$ e $I$ dado por
\begin{equation}
    O(i,j)= \sum_{u=-k}^{k} \sum_{v=-k}^{k} h(u,v)I(i-u,j-v)
\end{equation}

Esta operacion consiste en filtrar una imagen de dimension $(2k+1)x(2k+1)$ en la imagen $I$ y para cada pixel centrado en dicha imagen, 
calculando la operacion de convolucion.

El ajustes de los filtros necesarios para extraer caracteristicas puede resultar un proceso largo y tedioso que no siempre conduce a los 
resultados que uno esperaria, por lo que se puede utilizar machine learning para obtener los valores de los filtros, 
para que se pueden extrar de manera satisfactoria las caracteristicas de las imagenes.

Para esta tarea, al colocar la neuronas en cuadriculas de $2k x 2k$, pueden usarse como filtros de convolucion para 
la extracion de caracteristicas y modificar sus valores durante la propagacion hacia atras (backpropagation, metodo de entrenamiento 
que sera explicado mas adelante)(ver tema de filtros en paralelo $F_d$ profunidad de filtro hiperparametro).




\section{Requerimientos necesarios de la red}

\section{Implementación del algoritmo en Python 3}
